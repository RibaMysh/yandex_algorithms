"""
ПРИНЦИП РАБОТЫ

Принцип работы алгоритма сводится к тому, чтобы определить, есть ли у графа цикл.
Такой подход сработает, поскольку при создании графа программа меняет направление одного из типов дорог
(в нашем случае, дорог типа 'R') на противоположное, тем самым гарантируя,
что если из одной вершины можно вернуться обратна в неё же, то существует две разные дороги из одной вершины в другую.

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ

1. На вход программа получает число n — количество городов.
    Далее в n-1 строках указаны связи между городами в виде строк,
    состоящих из букв 'R' и 'B'. Затем программа создаёт граф в виде списка смежности,
    в котором дороги типа 'R' направлены в обратную сторону.
    После этого программа запускает обход DFS от первой вершины для поиска цикла в графе, если таковой имеется.
2. На каждом этапе работы программа обрабатывает ещё не посещённые вершины, а также достижимые вершины из текущей.
3. Программа завершает свою работу в двух случаях:
    Если в графе обнаружен цикл — программа выводит 'NO' и заканчивает свою работу.
    Если в графе не найдено цикла — программа выводит 'YES' и завершает работу.

ВРЕМЕННАЯ СЛОЖНОСТЬ

Пусть V — количество вершин, E — количество рёбер.

Затраченная память:

Дополнительная память требуется для хранения плотного графа в виде списка смежности, что требует O(V^2),
а также для хранения списка цветов, необходимого для отслеживания состояния вершин, что требует O(V).
Итого, необходимо O(V^2) дополнительной памяти.

Затраченное время:

Так как весь алгоритм сводится к нахождению цикла в ориентированном графе при помощи обхода DFS,
его сложность составляет O(V + E). Поскольку граф плотный, общая сложность алгоритма становится O(V^2).

"""

# id: 122800326

from enum import Enum


class Colors(Enum):
    WHITE = -1
    GRAY = 0
    BLACK = 1


def make_graph(vertexes) -> dict[int, list[int]]:
    ans = dict()
    for i in range(1, vertexes):
        line = input()
        for j in range(len(line)):
            letter = line[j]
            if letter == 'B':
                ans.setdefault(i, []).append(i + j + 1)
            else:
                ans.setdefault(i + j + 1, []).append(i)

    return ans


def has_cycle_dfs(vertex, colors):
    stack = [vertex]
    while stack:
        current_v = stack.pop()
        if colors[current_v] == Colors.WHITE:
            colors[current_v] = Colors.GRAY
            stack.append(current_v)
            for w in graph.get(current_v, []):
                if colors[w] == Colors.GRAY:
                    return True

                if colors[w] == Colors.WHITE:
                    stack.append(w)
        else:
            colors[current_v] = Colors.BLACK

    return False


def find_optimal(vertexes):
    colors = [Colors.WHITE] * (vertexes + 1)

    for v in range(1, vertexes + 1):
        if colors[v] == Colors.WHITE:
            if has_cycle_dfs(v, colors):
                print('NO')
                return
    print('YES')


n = int(input())
graph = make_graph(n)
find_optimal(n)
