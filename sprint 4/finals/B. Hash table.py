"""

ПРИНЦИП РАБОТЫ

Как мы знаем из курса структура данных "хеш-таблица" работает на одном из двух принципов:
- метод цепочек,
- метод открытой адресации.

Для своей реализации я выбрал метод цепочек. Принцип работы заключается в том, чтобы выделить начальный массив
и в случае необходимости записывать в каждую ячейку связанный список, который будет хранить корзины вида (key, value).
Принцип работы выбора ячейки, куда будет записываться новая корзина, очень прост — взятие модуля ключа
(ключ — целое число из условия задачи) от размера таблицы.
Эта индексная функция (если её так можно назвать) удовлетворяет всем четырём основным принципам.
Я думаю, также стоит поговорить о размере таблицы. Размер — простое число. Число я выбрал, можно сказать, случайно,
но также старался отталкиваться от количества команд на входе. Таблица работает на 3-х командах, каждая реализована
в соответствии с условием задачи и методом цепочек.

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ

1. На вход программа получает сначала n — число команд, затем в n строках встречаются команды трёх видов:
   - put key value
   - get key
   - delete key

Также стоит отметить, что ключ и значение — целое число (из условия задачи).

2. На каждом шаге работы программы обрабатывается очередная из трёх команд, и результат выводится на экран.

3. Программа завершает свою работу после обработки всех команд.

ВРЕМЕННАЯ СЛОЖНОСТЬ

Пусть S — загруженность отдельной ячейки массива, на котором работает таблица, n — число команд на входе.
Затраченная память:
грубо говоря, размер таблицы — n, значит, наша таблица потребляет O(n) памяти.

Затраченное время:
Для простоты рассуждения будем говорить, что S приблизительно равна единице,
чтобы программа могла работать за константное время. Разберём все 3 команды по отдельности:

1. put: В худшем случае программа работает за O(S) в тот момент, когда связанный список уже был создан и по нему нужно
полностью пройти, чтобы проверить наличие ключа и, при необходимости, перезаписать его.
O(S) ~= O(1).

2. get: По аналогии с первой командой худший случай — пройти полностью текущую ячейку и вернуть последнее значение.
O(S) ~= O(1).

3. delete: Как и две верхние команды, худший случай — пройтись по ячейке и удалить последний элемент.
Для удаления элемента я использую метод pop, который в худшем случае опять же работает за длину массива.
O(S) ~= O(1).

Разобрав все 3 команды, можно сделать вывод, что структура данных работает за O(S) ~= O(1).


"""
# id: 117777021
from typing import List, Optional


class HashTable:
    def __init__(self, size: int):
        self.size = size
        self.arr: List[Optional[List[List[int]]]] = [None] * size

    def put(self, key: int, value: int):
        index = key % self.size
        if self.arr[index] is None:
            self.arr[index] = [[key, value]]
            return

        for basket in self.arr[index]:
            if basket[0] == key:
                basket[1] = value
                return
        self.arr[index].append([key, value])

    def get(self, key: int):
        index = key % self.size
        if isinstance(self.arr[index], list):
            for basket in self.arr[index]:
                if basket[0] == key:
                    return basket[1]
        return None

    def delete(self, key):
        index = key % self.size
        if isinstance(self.arr[index], list):
            for i in range(len(self.arr[index])):
                if self.arr[index][i][0] == key:
                    arr = self.arr[index].pop(i)
                    return arr[1]
        return None


n = int(input())

if n < 1000:
    table_size = 509
elif 1000 <= n < 10_000:
    table_size = 4001
else:
    table_size = 50021

hash_table = HashTable(table_size)

for _ in range(n):
    command = input().split()

    if len(command) == 2:
        print(
            getattr(hash_table, command[0])(int(command[1]))
        )

    else:
        hash_table.put(int(command[1]), int(command[2]))
