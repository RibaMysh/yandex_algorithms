"""

**ПРИНЦИП РАБОТЫ**

Алгоритм работает на двух фундаментальных функциях `quick_sort` и `in_place`,
которые реализуют идею быстрой сортировки, а именно: выбрать опорный элемент, разделить массив на две части,
одна из которых меньше опорного элемента, а другая больше. Затем рекурсивно дойти до базового случая
(длина подмассива ≤ 1) и "склеить" все части.

**ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ**

1. На вход программа получает количество уникальных людей и их параметры.
В свою очередь, параметры состоят из трех переменных —
ключ (ник участника), количество решенных задач и сумма штрафов за задачи.

2. На каждом шаге рекурсии список специальным образом разбивается на определенные части
(ресурс, который дал мне алгоритм разбития на подмассивы: [Hackerrank Challenge](https://www.hackerrank.com/challenges/quicksort3/problem)),
о которых мы говорили выше. От каждой части мы запускаем процесс рекурсивно.

3. Программа завершает свою работу после прохождения всей глубины рекурсии, возвращая отсортированный массив.

**ВРЕМЕННАЯ СЛОЖНОСТЬ**

*n* — длина входящего массива.

Затраченная память —  все фкнкции, кроме quick_sort потребляют константное количество памяти.
Так как quick_sort(left) + quick_sort(right) создает новые массивы для левой и правой частей.
В худшем случае, например, если массив уже отсортирован, каждый рекурсивный вызов создает новые массивы
длиной n-1. Следовательно, в худшем случае глубина рекурсии будет n, что потребует O(n) дополнительной памяти.

Затраченное время на исполнение функций: программа состоит из четырех функций, разберем каждую по отдельности:

1. `less`: не требует дополнительной памяти и работает за константу, так как использует всего одну операцию — сравнение.

2. `swap`: также работает за константу, так как использует 2 операции:
   1. Получение элемента по индексу из массива постоянной длины.
   2. Перезапись элемента по индексу в массиве постоянной длины.

3. `in_place`: работает за O(n).
На первом шаге рекурсии O(n), на втором O(n/2), на третьем O(n/4) ... и так далее до O(1) на последнем шаге,
что в сумме дает O(n).
Также `in_place` использует функции `less` и `swap`, которые работают за константу,
 поэтому их использование значительно не влияет на скорость выполнения программы.

4. `quick_sort`: работает за O(n log n), так как массив в среднем случае постоянно делится пополам,
поэтому глубина рекурсии составляет log(n). Из-за того что на каждом шаге используется функция `in_place`,
мы получаем сложность: n * log(n) = O(n log n).

Подводя итоги, программа работает за O(n log n) времени.

"""


# id: 116720576
def less(person1, person2):
    name1, solved1, fine1 = person1
    name2, solved2, fine2 = person2
    if solved1 != solved2:
        return solved1 < solved2

    if fine1 != fine2:
        return not (fine1 < fine2)

    return name1 > name2




def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]


def partition(arr, low, high):
    pivot = arr[high]
    i = low
    for j in range(low, high):
        if less(arr[j], pivot):
            swap(arr, i, j)
            i += 1
    swap(arr, i, high)
    return i


def quick_sort(arr, low, high):
    if low < high:
        pivot_index = partition(arr, low, high)
        quick_sort(arr, low, pivot_index - 1)
        quick_sort(arr, pivot_index + 1, high)


n = int(input())
arr = []
for i in range(n):
    key, solved, fine = input().split()
    arr.append([key, int(solved), int(fine)])

quick_sort(arr, 0, len(arr) - 1)

for ans in arr[::-1]:
    print(ans[0])
