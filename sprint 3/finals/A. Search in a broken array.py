"""

**ПРИНЦИП РАБОТЫ**

Грубо говоря, алгоритм работает в два действия:
1. Находим отсортированную часть.
2. Проверяем, находится ли наш target в этой части.
Если да, то продолжаем работать с ней, иначе работаем с оставшейся частью.
   
Первым действием мы обязаны находить именно отсортированную часть,
потому что именно по ней мы сможем понять, где находится нужный нам элемент.

**ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ**

1. На вход мы получаем массив натуральных чисел, его длину и элемент,
индекс которого мы должны вернуть.

2. На каждом шаге работы алгоритма мы работаем с отрезком,
который постоянно уменьшается вдвое.
При любых корректных входных данных наш отрезок всегда будет уменьшаться,
независимо от того, находилось ли нужное нам число в массиве или нет.
Поэтому алгоритм не уйдёт в бесконечный цикл.

3. Алгоритм завершает свою работу в двух случаях:
    1. Нужное нам число найдено.
    2. Числа не было в нашем массиве, возвращается число -1.

**ВРЕМЕННАЯ СЛОЖНОСТЬ**

*n* — длина входящего массива.
Затраченная память — O(n) для хранения массива чисел и O(1) для хранения трёх целых чисел.
Затраченное время на исполнение функций - так как выше было сказано,
что отрезок постоянно делится на две части, => затраченное время — O(log_2(n)) => O(log(n)).

"""


# id: 116654926
def broken_search(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:

        mid = (left + right) // 2
        if nums[mid] == target:
            return mid

        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1

        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1


def test():
    arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
    assert broken_search(arr, 5) == 6
