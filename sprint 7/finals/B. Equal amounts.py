"""

ПРИНЦИП РАБОТЫ

Принцип работы алгоритма основан на динамическом программировании.
Мы пытаемся определить, можно ли разделить множество чисел на два подмножества с одинаковой суммой.
Для этого:
1. Сначала проверяем, является ли сумма всех чисел чётной. Если сумма нечётная, разделение невозможно.
2. Если сумма чётная, задача сводится к проверке: возможно ли получить сумму sum / 2 из подмножества чисел.
3. Используем массив dp, где dp[i] показывает, можно ли собрать сумму i из чисел.

Алгоритм проходит по каждому числу из последовательности и обновляет массив dp, начиная с конца.
Это позволяет избежать повторного использования одного и того же числа.

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ

1. На вход программа получает число n, а также n целых чисел.
2. На каждом шаге работы алгоритм заполняет массив dp единицами.
Если dp[i] = 1, то сумму i можно получить из некоторого подмножества чисел.
3. Алгоритм завершает свою работу, когда все числа обработаны,
и возвращает True, если массив можно разделить на две части с равной суммой, иначе False.

ВРЕМЕННАЯ СЛОЖНОСТЬ

Пусть s — сумма исходного массива.

Затраченная память:
    Память выделяется только на массив dp, длина которого равна s + 1.
    Затраченная память: O(s).

Затраченное время:
    Для каждого числа алгоритм проходит по массиву dp длиной s.
    Затраченное время: O(n * s).

"""


# id: 127303017
def can_diff(seq: list[int]) -> bool:
    s = sum(seq)

    if s % 2 != 0:
        return False

    dp = [False for _ in range(s + 1)]
    dp[0] = True

    for num in seq:
        for i in range(s, -1, -1):
            if dp[i]:
                dp[i + num] = True

    return dp[s // 2]


n = int(input())
lst = list(map(int, input().split()))
print(can_diff(lst))
